<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVR Ultimate: Kernels & Stability</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --text: #e2e8f0;
            --accent: #38bdf8;
            --danger: #f87171;
            --success: #4ade80;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }

        h2 { margin: 10px 0; color: var(--accent); font-weight: 300; }

        .layout {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            width: 100%;
            max-width: 1100px;
        }

        canvas {
            background: #151e2e;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid #334155;
            cursor: crosshair;
        }

        .controls {
            background: var(--panel);
            padding: 20px;
            border-radius: 8px;
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border: 1px solid #334155;
            height: fit-content;
        }

        /* Form Styles */
        label { display: flex; justify-content: space-between; font-size: 0.85em; color: #94a3b8; margin-bottom: 5px; }
        input[type="range"] { width: 100%; accent-color: var(--accent); cursor: pointer; }
        select {
            width: 100%; padding: 8px; background: #0f172a; color: white;
            border: 1px solid #334155; border-radius: 4px; font-size: 1rem;
        }

        .section-title {
            font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px;
            color: var(--accent); border-bottom: 1px solid #334155; padding-bottom: 5px; margin-top: 10px;
        }

        .hidden { display: none; }

        .btn-group { display: flex; gap: 10px; margin-top: 10px; }
        button {
            flex: 1; padding: 10px; border: none; border-radius: 4px;
            font-weight: 600; cursor: pointer; transition: 0.2s;
        }
        .btn-reset { background: var(--accent); color: #000; }
        .btn-reset:hover { background: #7dd3fc; }
        .btn-clear { background: rgba(248,113,113,0.1); color: var(--danger); border: 1px solid var(--danger); }
        .btn-clear:hover { background: var(--danger); color: white; }

        .legend { font-size: 0.8em; display: flex; gap: 10px; justify-content: center; margin-top:5px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
    </style>
</head>
<body>

    <h2>SVR Ultimate Playground</h2>

    <div class="layout">
        <div>
            <canvas id="svrCanvas" width="600" height="450"></canvas>
            <div class="legend">
                <span><span class="dot" style="background:#f87171"></span> Support Vector</span>
                <span><span class="dot" style="background:#4b5563"></span> Ignored Point</span>
                <span><span class="dot" style="background:#38bdf8"></span> Prediction</span>
            </div>
        </div>

        <div class="controls">
            
            <div class="section-title">1. Choose Kernel (The "Brain")</div>
            <select id="kernelSelect" onchange="updateKernelUI()">
                <option value="rbf">RBF (Radial Basis Function)</option>
                <option value="poly">Polynomial</option>
                <option value="linear">Linear</option>
            </select>
            <div id="kernelDesc" style="font-size:0.8em; color:#64748b; margin-top:5px; font-style:italic;">
                Best for complex, wobbly data. Uses localized curves.
            </div>

            <div id="ui-rbf">
                <label><span>Gamma (Curvature)</span> <span id="valGamma">3.0</span></label>
                <input type="range" id="rngGamma" min="0.1" max="10" step="0.1" value="3.0">
            </div>

            <div id="ui-poly" class="hidden">
                <label><span>Degree (Power)</span> <span id="valDegree">2</span></label>
                <input type="range" id="rngDegree" min="2" max="5" step="1" value="2">
                
                <label><span>Coeff (Offset)</span> <span id="valCoeff">1.0</span></label>
                <input type="range" id="rngCoeff" min="0" max="5" step="0.5" value="1.0">
            </div>

            <div class="section-title">2. Tune Model</div>
            
            <label><span>Epsilon (Tube Width)</span> <span id="valEps">0.10</span></label>
            <input type="range" id="rngEps" min="0.01" max="0.5" step="0.01" value="0.1">

            <label><span>C (Penalty Cost)</span> <span id="valC">10</span></label>
            <input type="range" id="rngC" min="1" max="100" step="1" value="10">

            <div class="section-title">3. Fix Shaking</div>
            <label><span>Learning Rate (Speed vs Stability)</span> <span id="valLr">0.01</span></label>
            <input type="range" id="rngLr" min="0.001" max="0.1" step="0.001" value="0.01">
            <div style="font-size:0.75em; color:#94a3b8; margin-top:-5px;">* Lower this if line is shaking too much.</div>

            <div class="btn-group">
                <button class="btn-reset" onclick="resetData()">Reset: Sine Wave</button>
                <button class="btn-clear" onclick="clearData()">Clear All</button>
            </div>
        </div>
    </div>

<script>
    /* --- 1. SETUP --- */
    const canvas = document.getElementById('svrCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI References
    const ui = {
        kernel: document.getElementById('kernelSelect'),
        desc: document.getElementById('kernelDesc'),
        rbf: document.getElementById('ui-rbf'),
        poly: document.getElementById('ui-poly'),
        // Sliders
        gamma: document.getElementById('rngGamma'),
        degree: document.getElementById('rngDegree'),
        coeff: document.getElementById('rngCoeff'),
        eps: document.getElementById('rngEps'),
        c: document.getElementById('rngC'),
        lr: document.getElementById('rngLr'),
        // Values
        vGamma: document.getElementById('valGamma'),
        vDegree: document.getElementById('valDegree'),
        vCoeff: document.getElementById('valCoeff'),
        vEps: document.getElementById('valEps'),
        vC: document.getElementById('valC'),
        vLr: document.getElementById('valLr')
    };

    // Model State
    let points = [];
    let alphas = [];
    let bias = 0;
    
    // Parameters
    let params = {
        kernel: 'rbf',
        gamma: 3.0,
        degree: 2,
        coeff: 1.0,
        epsilon: 0.1,
        C: 10,
        lr: 0.01
    };

    /* --- 2. KERNEL FUNCTIONS --- */
    function kernel(x1, x2) {
        if (params.kernel === 'linear') {
            return x1 * x2;
        } 
        else if (params.kernel === 'poly') {
            // Polynomial: (gamma*u'*v + coeff)^degree
            // We use gamma=1 for simplicity in UI, user controls coeff/degree
            let base = (x1 * x2) + params.coeff;
            return Math.pow(base, params.degree);
        } 
        else { 
            // RBF
            let d = x1 - x2;
            return Math.exp(-params.gamma * d * d);
        }
    }

    /* --- 3. TRAINING LOOP (SGD) --- */
    function predict(x) {
        let sum = bias;
        for(let i=0; i<points.length; i++) {
            if (alphas[i] === 0) continue; // Optimization
            sum += alphas[i] * kernel(x, points[i].x);
        }
        return sum;
    }

    function trainStep() {
        if(points.length === 0) return;

        // Perform multiple SGD steps per frame for speed
        let iterations = 50; 
        
        for(let k=0; k<iterations; k++) {
            // Pick random point
            let i = Math.floor(Math.random() * points.length);
            let p = points[i];
            
            let y_pred = predict(p.x);
            let error = p.y - y_pred;
            
            // SVR Update Rule:
            // Only update if error is outside the Epsilon tube
            if (Math.abs(error) > params.epsilon) {
                let sign = Math.sign(error);
                let update = params.lr * params.C * sign; // Gradient step
                
                // Stability Check: Don't explode
                if (Math.abs(update) > 0.5) update = 0.5 * sign;

                alphas[i] += update;
                bias += update * 0.5; // Bias learns slower
            }

            // Weight Decay (Regularization) - Keeps alphas from exploding
            // This is critical for stability!
            alphas[i] *= 0.999;
        }
    }

    /* --- 4. UI HANDLING --- */
    function updateKernelUI() {
        params.kernel = ui.kernel.value;
        
        // Toggle visibility
        ui.rbf.classList.add('hidden');
        ui.poly.classList.add('hidden');
        
        if (params.kernel === 'rbf') {
            ui.rbf.classList.remove('hidden');
            ui.desc.innerText = "Local Curves. Good for wiggles. Uses Gamma.";
        } else if (params.kernel === 'poly') {
            ui.poly.classList.remove('hidden');
            ui.desc.innerText = "Wide Arcs. Good for parabolas. Uses Degree.";
        } else {
            ui.desc.innerText = "Straight Line. Good for simple trends.";
        }
        
        // Reset model weights when kernel changes to avoid chaos
        alphas = new Array(points.length).fill(0);
        bias = 0;
    }

    // Slider Event Listeners
    ui.gamma.oninput = e => { params.gamma = parseFloat(e.target.value); ui.vGamma.innerText = params.gamma; };
    ui.degree.oninput = e => { params.degree = parseInt(e.target.value); ui.vDegree.innerText = params.degree; alphas.fill(0); };
    ui.coeff.oninput = e => { params.coeff = parseFloat(e.target.value); ui.vCoeff.innerText = params.coeff; alphas.fill(0); };
    ui.eps.oninput = e => { params.epsilon = parseFloat(e.target.value); ui.vEps.innerText = params.epsilon.toFixed(2); };
    ui.c.oninput = e => { params.C = parseFloat(e.target.value); ui.vC.innerText = params.C; };
    ui.lr.oninput = e => { params.lr = parseFloat(e.target.value); ui.vLr.innerText = params.lr; };

    /* --- 5. CANVAS & INTERACTION --- */
    function resetData() {
        points = [];
        for(let x = -0.8; x <= 0.8; x += 0.15) {
            // Sine wave pattern
            let y = Math.sin(x * 3.5) * 0.6;
            points.push({x, y});
        }
        alphas = new Array(points.length).fill(0);
        bias = 0;
    }

    function clearData() {
        points = [];
        alphas = [];
        bias = 0;
    }

    canvas.addEventListener('mousedown', e => {
        const rect = canvas.getBoundingClientRect();
        // Map pixel to -1..1 coordinates
        let x = (e.clientX - rect.left - canvas.width/2) / (canvas.width/2.5);
        let y = -(e.clientY - rect.top - canvas.height/2) / (canvas.height/2.5);
        
        if (e.button === 2) { // Right click remove
             // Simple remove logic (removes last added for simplicity in demo)
             points.pop(); alphas.pop();
        } else {
            points.push({x, y});
            alphas.push(0);
        }
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    /* --- 6. RENDER LOOP --- */
    function draw() {
        ctx.fillStyle = "#151e2e";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let cx = canvas.width / 2;
        let cy = canvas.height / 2;
        let scale = canvas.width / 2.5;

        // 1. Draw Prediction & Tube
        ctx.beginPath();
        let started = false;

        // Draw Tube Fill
        ctx.fillStyle = "rgba(56, 189, 248, 0.1)";
        ctx.beginPath();
        
        // Top edge
        for(let i=0; i<=canvas.width; i+=4) {
            let x = (i - cx) / scale;
            let y = predict(x) + params.epsilon;
            let py = -y * scale + cy;
            if (i===0) ctx.moveTo(i, py); else ctx.lineTo(i, py);
        }
        // Bottom edge
        for(let i=canvas.width; i>=0; i-=4) {
            let x = (i - cx) / scale;
            let y = predict(x) - params.epsilon;
            let py = -y * scale + cy;
            ctx.lineTo(i, py);
        }
        ctx.fill();

        // Draw Center Line
        ctx.strokeStyle = "#38bdf8";
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let i=0; i<=canvas.width; i+=4) {
            let x = (i - cx) / scale;
            let y = predict(x);
            let py = -y * scale + cy;
            if (i===0) ctx.moveTo(i, py); else ctx.lineTo(i, py);
        }
        ctx.stroke();

        // 2. Draw Points
        points.forEach((p) => {
            let px = p.x * scale + cx;
            let py = -p.y * scale + cy;
            
            let pred = predict(p.x);
            let error = Math.abs(p.y - pred);
            
            // Support Vector check
            let isSV = error > params.epsilon * 0.95; 

            ctx.beginPath();
            ctx.arc(px, py, isSV ? 6 : 4, 0, Math.PI*2);
            
            if (isSV) {
                ctx.fillStyle = "#f87171"; // Red
                ctx.fill();
                // Draw error bar
                ctx.beginPath();
                ctx.strokeStyle = "rgba(248,113,113,0.3)";
                ctx.moveTo(px, py);
                
                // Draw line to closest tube edge
                let tubeY = (p.y > pred) ? pred + params.epsilon : pred - params.epsilon;
                let pyTube = -tubeY * scale + cy;
                ctx.lineTo(px, pyTube);
                ctx.stroke();

            } else {
                ctx.fillStyle = "#4b5563"; // Gray
                ctx.fill();
            }
        });

        trainStep();
        requestAnimationFrame(draw);
    }

    // Start
    resetData();
    draw();

</script>
</body>
</html>