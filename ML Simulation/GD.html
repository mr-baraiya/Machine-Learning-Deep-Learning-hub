<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Descent Simulator: y = x²</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f4f4f9; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        h1 { color: #333; margin-bottom: 10px; }
        .container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        
        /* Canvas Styling */
        #graphCanvas { background-color: #fff; border: 2px solid #ddd; box-shadow: 0 4px 6px rgba(0,0,0,0.1); cursor: crosshair; }
        
        /* Controls Styling */
        .controls { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); width: 300px; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-weight: bold; margin-bottom: 5px; color: #555; }
        input[type=range] { width: 100%; }
        .value-display { float: right; color: #007bff; font-weight: bold; }
        
        /* Stats Box */
        .stats { margin-top: 20px; padding: 10px; background: #eef; border-radius: 5px; font-family: monospace; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        
        /* Buttons */
        .btn-group { display: flex; gap: 10px; margin-top: 20px; }
        button { flex: 1; padding: 10px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; transition: 0.2s; }
        .btn-step { background-color: #ffc107; color: #333; }
        .btn-run { background-color: #28a745; color: white; }
        .btn-reset { background-color: #dc3545; color: white; }
        button:hover { opacity: 0.9; transform: translateY(-1px); }
        button:disabled { background-color: #ccc; cursor: not-allowed; }

        .legend { font-size: 0.85em; color: #666; margin-top: 10px; }
        .legend span { display: inline-block; width: 12px; height: 12px; margin-right: 5px; border-radius: 50%; }
    </style>
</head>
<body>

    <h1>Gradient Descent Simulator (y = x²)</h1>
    <p>Visualize how the "Learning Rate" affects optimization.</p>

    <div class="container">
        <canvas id="graphCanvas" width="600" height="400"></canvas>

        <div class="controls">
            <div class="control-group">
                <label>Starting X Position <span id="val-start" class="value-display">-4</span></label>
                <input type="range" id="startPos" min="-5" max="5" step="0.1" value="-4">
            </div>

            <div class="control-group">
                <label>Learning Rate (Alpha) <span id="val-lr" class="value-display">0.1</span></label>
                <input type="range" id="learningRate" min="0.01" max="1.1" step="0.01" value="0.1">
                <small style="color: #888; display: block; margin-top: 5px;">
                    Try 0.1 (Slow), 0.8 (Fast), 1.05 (Explodes!)
                </small>
            </div>

            <div class="stats">
                <div class="stat-row"><span>Iteration:</span> <span id="stat-iter">0</span></div>
                <div class="stat-row"><span>Current X:</span> <span id="stat-x">0.00</span></div>
                <div class="stat-row"><span>Gradient (2x):</span> <span id="stat-grad">0.00</span></div>
                <div class="stat-row"><span>Cost (x²):</span> <span id="stat-cost">0.00</span></div>
            </div>

            <div class="btn-group">
                <button class="btn-step" id="btnStep" onclick="step()">Step >></button>
                <button class="btn-run" id="btnRun" onclick="toggleRun()">Auto Run</button>
            </div>
            <div class="btn-group">
                 <button class="btn-reset" onclick="resetSim()">Reset</button>
            </div>
            
            <div class="legend">
                <p><span style="background:red;"></span>Current Position</p>
                <p><span style="background:rgba(255,0,0,0.3);"></span>Previous Steps</p>
                <p><span style="background:green;"></span>Goal (Minima)</p>
            </div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    
    // Simulation State
    let currentX = -4;
    let learningRate = 0.1;
    let iteration = 0;
    let history = []; // Stores previous positions for visualization
    let isRunning = false;
    let runInterval;

    // Graph Settings
    const scaleX = 40; // Pixels per unit X
    const scaleY = 40; // Pixels per unit Y
    const centerX = canvas.width / 2;
    const centerY = canvas.height - 50; // Shift origin down a bit

    // HTML Elements
    const elStartPos = document.getElementById('startPos');
    const elLearningRate = document.getElementById('learningRate');
    const elValStart = document.getElementById('val-start');
    const elValLr = document.getElementById('val-lr');
    const btnRun = document.getElementById('btnRun');

    // Stats Elements
    const statIter = document.getElementById('stat-iter');
    const statX = document.getElementById('stat-x');
    const statGrad = document.getElementById('stat-grad');
    const statCost = document.getElementById('stat-cost');

    // --- Core Logic ---

    // The Function: y = x^2
    function f(x) { return x * x; }
    
    // The Derivative: y' = 2x
    function df(x) { return 2 * x; }

    function step() {
        // Save history
        history.push(currentX);

        // 1. Calculate Gradient
        const gradient = df(currentX);

        // 2. Update X (Gradient Descent Formula)
        // New = Old - (Learning Rate * Gradient)
        currentX = currentX - (learningRate * gradient);

        iteration++;
        updateUI();
        draw();

        // Stop auto-run if we are basically at 0
        if(Math.abs(currentX) < 0.001 && isRunning) {
            toggleRun();
        }
        // Stop if we explode (infinity)
        if(Math.abs(currentX) > 50 && isRunning) {
            alert("Gradient Exploded! The ball flew away. Try a smaller Learning Rate.");
            toggleRun();
        }
    }

    function toggleRun() {
        if(isRunning) {
            clearInterval(runInterval);
            isRunning = false;
            btnRun.innerText = "Auto Run";
            btnRun.style.backgroundColor = "#28a745";
        } else {
            isRunning = true;
            btnRun.innerText = "Stop";
            btnRun.style.backgroundColor = "#555";
            runInterval = setInterval(step, 200); // 200ms per step
        }
    }

    function resetSim() {
        if(isRunning) toggleRun();
        currentX = parseFloat(elStartPos.value);
        learningRate = parseFloat(elLearningRate.value);
        iteration = 0;
        history = [];
        updateUI();
        draw();
    }

    // --- Visualization / Drawing ---

    function toCanvasX(x) { return centerX + (x * scaleX); }
    function toCanvasY(y) { return centerY - (y * scaleY); }

    function drawGrid() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.strokeStyle = "#eee";
        ctx.lineWidth = 1;

        // X Axis
        ctx.beginPath();
        ctx.moveTo(0, centerY);
        ctx.lineTo(canvas.width, centerY);
        ctx.stroke();

        // Y Axis
        ctx.beginPath();
        ctx.moveTo(centerX, 0);
        ctx.lineTo(centerX, canvas.height);
        ctx.stroke();
    }

    function drawParabola() {
        ctx.beginPath();
        ctx.strokeStyle = "#007bff";
        ctx.lineWidth = 2;
        
        let startGraph = -centerX / scaleX;
        let endGraph = (canvas.width - centerX) / scaleX;

        for (let x = startGraph; x <= endGraph; x += 0.1) {
            let y = f(x);
            if (x === startGraph) ctx.moveTo(toCanvasX(x), toCanvasY(y));
            else ctx.lineTo(toCanvasX(x), toCanvasY(y));
        }
        ctx.stroke();
    }

    function drawPoint(x, color, radius, alpha=1) {
        let y = f(x);
        let cx = toCanvasX(x);
        let cy = toCanvasY(y);

        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.globalAlpha = alpha;
        ctx.fill();
        ctx.globalAlpha = 1; // Reset
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    function drawTangent(x) {
        // Draw a small line indicating slope direction
        let y = f(x);
        let slope = df(x);
        
        // Find two points on the tangent line
        let length = 1; // logical units
        let x1 = x - 0.5; 
        let y1 = y - (slope * 0.5);
        let x2 = x + 0.5;
        let y2 = y + (slope * 0.5);

        ctx.beginPath();
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.moveTo(toCanvasX(x1), toCanvasY(y1));
        ctx.lineTo(toCanvasX(x2), toCanvasY(y2));
        ctx.stroke();
        ctx.setLineDash([]);
    }

    function draw() {
        drawGrid();
        drawParabola();

        // Draw History (Ghost trails)
        history.forEach(hX => {
            drawPoint(hX, "red", 4, 0.2);
        });

        // Draw Current Position
        drawTangent(currentX);
        drawPoint(currentX, "red", 8, 1);
        
        // Draw Goal
        drawPoint(0, "green", 5, 1);
    }

    function updateUI() {
        statIter.innerText = iteration;
        statX.innerText = currentX.toFixed(4);
        statGrad.innerText = df(currentX).toFixed(4);
        statCost.innerText = f(currentX).toFixed(4);

        elValStart.innerText = elStartPos.value;
        elValLr.innerText = elLearningRate.value;
    }

    // --- Event Listeners ---
    elStartPos.addEventListener('input', () => { 
        elValStart.innerText = elStartPos.value; 
        resetSim(); 
    });

    elLearningRate.addEventListener('input', () => { 
        elValLr.innerText = elLearningRate.value; 
        learningRate = parseFloat(elLearningRate.value);
    });

    // Initialize
    resetSim();

</script>
</body>
</html>